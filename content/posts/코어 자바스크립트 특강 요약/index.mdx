---
title: 코어 자바스크립트 특강 요약
date: 2019-12-01
tags:
  - 코어 자바스크립트
  - 특강
  - 요약
  - 자바스크립트
---

2019년 11월 31일 강남에서 진행된 코어 자바스크립트 특강을 듣고 작성한 요약본입니다.

#### Data Type

- Primitive Type, Reference Type 왜 구분해야 하는가?
- 메모리 할당할 때 Reference Type은 할당 공간이 더 필요하다.
- 참조 카운트가 0이 될 때, 즉 데이터가 참조된 곳이 없을 때 가비지 컬렉팅이 된다.
- 같은 객체를 참조하고 있을 때 객체의 값이 변하면? - 불변성 필요.

#### Execution Context

- (실행에 필요한) (코드 흐름상의 배경이 되는 조건/환경)
- (동일한 조건/환경을 지니는 코드 뭉치) (를 실행할 때 필요한 조건/환경 정보)
- (함수 or 전역 공간) (를 실행할 때 필요한 환경 정보(를 담은 객체))
- 스택처럼 실행된다. 콜 스택이 사용된다.
- Lexical(어휘적/사전적) Environment(환경)
- environmentRecord: 현재 문맥의 식별자 정보의 수집 과정 - 이것을 Hoisting이라 부른다.
- Hoisting: (식별자 정보)를 끌어올리다. 맨 위에 끌어 올려져 있는 환경이 environmentRecord이다.
- OuterEnvironmentReference: 현재 문맥에 관련 있는 외부 식별자 정보.
- OuterEnvironmentReference가 Scope Chain(inner에서 outer로 찾는다.)을 만든다.
- inner는 inner에만 국한된다. outer는 inner에서도 접근 가능하다.
- inner에서 outer 방향으로 찾기 때문에 outer에 같은 이름의 변수가 있어도 inner에서 먼저 찾으면 거기서 멈춘다. (Shadowing)

#### This Binding

- 실행 컨텍스트가 활성화될 때(함수가 호출될 때) 바인딩된다.
- 전역공간에서(window, global)는 당연히 this는 전역.
- 함수 호출시에도 전역 객체 가르킨다. 호출한 대상이 전역이니까. 근데 함수 내에서 함수를 호출해도 전역 객체 가르킨다.
- 메소드 호출시 메소드 호출 주체(점 앞에 애)를 가르킨다. 그런데 메소드 내부에서 함수 호출시? 해당 함수는 전역 객체 가르킨다. 이를 메소드에서 this를 변수에 담아서 함수 내에서 호출하는 방식으로 우회할 수 있다.
- 콜백 호출시 기본적으로는 함수 내부에서와 동일하다. 어디서 실행하든 그냥 실행하면 전역객체가 this이다. apply, call, bind 같은 걸로 this 바인딩을 해주면 바인딩된 this가 된다.
- setTimeOut 안에서 this 호출하면 전역객체. bind로 this binding 가능.
- addEventListener에서 click 바인딩하고 this를 출력하면? 이 때는 click 호출한 DOM 객체.
- 생성자함수 호출시(new로 새로운 인스턴스 생성)는 생성된 인스턴스가 this가 된다.
- call, apply는 즉시 실행. bind는 새로운 함수 생성(currying)

#### Callback Function

- 호출해서 돌려줄 함수. 제어권을 맡긴다.
- 예를 들면 setInterval(콜백함수, 시간); 이면 setInterval에 콜백함수의 제어권을 넘긴다.
- forEach의 두 번째 인자로 thisArg를 받는다.
- 다른 함수의 인자로 콜백함수를 전달하면 A가 B의 제어권을 갖게 된다.
- A가 미리 정해둔 방식에 따라 B를 호출한다.
- 미리 정해둔 방식이란 어떤 시점에 콜백을 호출할지, 인자에는 어떤 값들을 지정할지, this에는 무엇을 바인딩할지 등이다.
- 주의! 콜백은 함수다. 메소드가 아니다. 함수로 넘기는 것과 메소드로 넘기는 것은 다르다. 메소드로 넘기면 this가 해당 메소드를 가지고 있는 객체지만, obj.method로 넘기더라도 이를 forEach(obj.method)처럼 넘기면 메소드가 아니라 method라는 함수 자체를 넘기는 것이기 때문에 this 바인딩은 전역이 된다.

#### Closure

- 실행 컨텍스트 A와 함수 B가 콤비가 되어 무언가를 한다.
- 컨텍스트 A에서 선언한 변수를 내부함수 B에서 접근할 경우에만 발생하는 특수한 현상.
- 컨텍스트 A에서 선언한 변수 a를 참조하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상.
- 지역변수가 함수 종료 후에도 사라지지 않게 할 수 있다.
- 내부 지역변수를 직접 접근하지 못하고 함수를 통해서만 접근하게 할 수도 있다. 지역변수 생성해두고 게터세터 만들어서 반환하면 된다.

#### Prototype

- new로 Instance를 만들면, constructor의 prototype은 Instance의 \__proto\__가 된다. \__proto\__는 호출할 때 생략할 수 있다.
- 같은 constructor로 만들어진 인스턴스라면, prototype에 함수를 생성해두고 상속받아서 쓸 수 있다.
- prototype의 prototype을 chaining해서 값을 받아올 수 있다. 가장 상단에는 Object.prototype이 있는데, chaining을 통해 어디서든 쓸 수 있으니 가장 범용적인 메서드들이 있다.
- 그럼 Object에서만 쓸 수 있는 메소드들은 어떻게 하지? Object.prototype에 넣어두면 어디서든 다 쓸 수 있으니 문제가 된다. Object 안에 다 넣어두었다. 그래서 Object.assign()같이 Object를 호출해서 써야만 한다.

#### Class

- static method, property는 인스턴스에서는 접근 불가하다. prototype method는 접근 가능하다. Employee.getName은 안되고 Person.getName으로 접근하던지 Employee.prototype.getName으로 접근해야 한다.
- Employee.prototype = new Person()를 하면 prototype method chaining 가능하지만, 이 경우 constructor가 사라지므로, constructor가 필요하면 Employee.prototype.constructor = Employee를 해서 만들어주면 된다.
- Bridge라는 생성자 만들어서 property는 없고 prototype의 메소드는 상속받게 할 수도 있다.
- 지금은 extends로 간단하게 해결할 수 있다.